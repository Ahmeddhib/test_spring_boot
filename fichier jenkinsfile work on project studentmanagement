pipeline {
    agent any

    environment {
        DOCKER_IMAGE = "ahmedwolf/spring-test3"
        DOCKER_TAG = "build-${env.BUILD_NUMBER}"
        DOCKER_LATEST = "latest"
        // Configuration SonarQube avec token
        SONAR_HOST = "http://192.168.49.1:9000"
        // REMPLACEZ sqp_... PAR VOTRE TOKEN R√âEL
        SONAR_TOKEN = "squ_89c7bc3d712cf67b71452a9253ceb6d571849d3e"
    }

    stages {
        stage('Checkout') {
            steps {
                checkout([$class: 'GitSCM',
                          branches: [[name: '*/main']],
                          userRemoteConfigs: [[url: 'https://github.com/Ahmeddhib/StudentsManagement-DevOps.git']],
                          extensions: [[$class: 'CloneOption', shallow: true, depth: 1, noTags: false, timeout: 10]]
                ])
            }
        }

        stage('SonarQube Analysis - With Token') {
            steps {
                script {
                    echo "üîç Analyse SonarQube en cours..."

                    // Version avec token (plus s√©curis√©e)
                    sh """
                        mvn sonar:sonar \
                            -Dsonar.projectKey=StudentsManagement \
                            -Dsonar.projectName="Students Management System" \
                            -Dsonar.host.url=${SONAR_HOST} \
                            -Dsonar.login=${SONAR_TOKEN} \
                            -Dsonar.sources=src/main/java \
                            -Dsonar.java.binaries=target/classes
                    """

                    echo "‚úÖ Analyse SonarQube termin√©e"
                }
            }
        }

        // D√âCOMMENTEZ cette √©tase plus tard
        /*
        stage('Wait for Quality Gate') {
            steps {
                script {
                    timeout(time: 10, unit: 'MINUTES') {
                        waitForQualityGate abortPipeline: true
                    }
                    echo "‚úÖ Quality Gate pass√©e avec succ√®s !"
                }
            }
        }
        */

        stage('Check for Code Changes') {
            steps {
                script {
                    // Calculer le hash SHA256 du code source
                    sh '''
                        # Calculer le hash de tous les fichiers sources
                        find . -type f \
                            -name "*.java" -o \
                            -name "*.xml" -o \
                            -name "*.properties" -o \
                            -name "*.yml" -o \
                            -name "*.yaml" -o \
                            -name "Dockerfile" -o \
                            -name "pom.xml" -o \
                            -name "Jenkinsfile" | \
                        sort | \
                        xargs cat 2>/dev/null | \
                        sha256sum | \
                        awk '{print $1}' > current_code_hash.txt

                        echo "Hash calcul√© : $(cat current_code_hash.txt)"
                    '''

                    // Lire le hash actuel
                    def currentHash = readFile('current_code_hash.txt').trim()

                    // Essayer de lire le hash pr√©c√©dent (stock√© dans workspace)
                    def previousHash = ""
                    try {
                        previousHash = readFile('previous_code_hash.txt').trim()
                        echo "Hash pr√©c√©dent trouv√© : ${previousHash}"
                    } catch(e) {
                        echo "Aucun hash pr√©c√©dent trouv√© (premier build?)"
                        previousHash = ""
                    }

                    // Comparer les hashs
                    if (currentHash != previousHash) {
                        echo "üîÑ Changements d√©tect√©s dans le code !"
                        env.BUILD_NEEDED = "true"
                    } else {
                        echo "‚úÖ Aucun changement dans le code"
                        env.BUILD_NEEDED = "false"
                    }

                    // Sauvegarder le hash actuel pour le prochain build
                    writeFile file: 'previous_code_hash.txt', text: currentHash

                    echo "Build n√©cessaire ? ${env.BUILD_NEEDED}"
                }
            }
        }

        stage('Build Maven Project') {
            when {
                expression { env.BUILD_NEEDED == "true" }
            }
            steps {
                sh 'mvn clean install -DskipTests -B'
            }
        }

        stage('Build Docker Image') {
            when {
                expression { env.BUILD_NEEDED == "true" }
            }
            steps {
                script {
                    // Builder avec le tag unique
                    sh "docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} ."
                    // Tagger aussi en latest pour usage local
                    sh "docker tag ${DOCKER_IMAGE}:${DOCKER_TAG} ${DOCKER_IMAGE}:${DOCKER_LATEST}"
                    echo "‚úÖ Image Docker construite : ${DOCKER_IMAGE}:${DOCKER_TAG}"
                }
            }
        }

        stage('Push Docker Image') {
            steps {
                script {
                    withCredentials([usernamePassword(
                        credentialsId: 'dockerhub',
                        usernameVariable: 'DOCKER_USER',
                        passwordVariable: 'DOCKER_PASS'
                    )]) {
                        sh '''
                            echo "Authentification sur Docker Hub..."
                            echo \$DOCKER_PASS | docker login -u \$DOCKER_USER --password-stdin

                            echo "Images disponibles localement :"
                            docker images | grep ${DOCKER_IMAGE} || echo "Aucune image trouv√©e"

                            # V√©rifier si l'image avec le tag sp√©cifique existe
                            if docker inspect ${DOCKER_IMAGE}:${DOCKER_TAG} > /dev/null 2>&1; then
                                echo "Push de l'image avec tag ${DOCKER_TAG}..."
                                docker push ${DOCKER_IMAGE}:${DOCKER_TAG}
                            else
                                echo "‚ö†Ô∏è Image ${DOCKER_IMAGE}:${DOCKER_TAG} non trouv√©e localement"
                                echo "‚Üí Skip du push pour ce tag"
                            fi

                            # Push du tag latest seulement si le build a √©t√© fait
                            if [ "${BUILD_NEEDED}" = "true" ]; then
                                echo "Push de l'image avec tag latest..."
                                docker push ${DOCKER_IMAGE}:${DOCKER_LATEST}
                            else
                                echo "Skip push latest (aucun changement d√©tect√©)"
                            fi
                        '''
                    }
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {
                    // V√©rifier d'abord si l'image existe localement ou sur DockerHub
                    sh '''
                        echo "üîÑ D√©ploiement sur Kubernetes..."

                        # V√©rifier si on a une image √† d√©ployer
                        if docker inspect ${DOCKER_IMAGE}:${DOCKER_TAG} > /dev/null 2>&1; then
                            echo "Utilisation de l'image locale: ${DOCKER_IMAGE}:${DOCKER_TAG}"
                            IMAGE_TO_DEPLOY="${DOCKER_IMAGE}:${DOCKER_TAG}"
                        elif docker inspect ${DOCKER_IMAGE}:${DOCKER_LATEST} > /dev/null 2>&1; then
                            echo "Utilisation de l'image latest locale: ${DOCKER_IMAGE}:${DOCKER_LATEST}"
                            IMAGE_TO_DEPLOY="${DOCKER_IMAGE}:${DOCKER_LATEST}"
                        else
                            echo "‚ö†Ô∏è Aucune image locale trouv√©e, utilisation de latest depuis DockerHub"
                            IMAGE_TO_DEPLOY="${DOCKER_IMAGE}:${DOCKER_LATEST}"
                        fi

                        echo "Image √† d√©ployer: \${IMAGE_TO_DEPLOY}"

                        # Cr√©er ou mettre √† jour le d√©ploiement
                        if kubectl get deployment spring-test3 > /dev/null 2>&1; then
                            echo "Mise √† jour du d√©ploiement existant..."
                            kubectl set image deployment/spring-test3 \
                                spring-test3=\${IMAGE_TO_DEPLOY} \
                                --record
                        else
                            echo "Cr√©ation d'un nouveau d√©ploiement..."
                            # Cr√©er un d√©ploiement simple (√† adapter selon vos besoins)
                            kubectl create deployment spring-test3 \
                                --image=\${IMAGE_TO_DEPLOY} \
                                --replicas=1
                        fi

                        # V√©rifier le statut du rollout
                        kubectl rollout status deployment/spring-test3 --timeout=300s || true

                        echo "‚úÖ D√©ploiement Kubernetes termin√©"

                        # Afficher les informations
                        echo "--- Informations du d√©ploiement ---"
                        kubectl get deployment spring-test3 -o wide || echo "D√©ploiement non trouv√©"
                    '''
                }
            }
        }
    }

    post {
        always {
            echo "üßπ Nettoyage..."
            sh '''
                # D√©connexion Docker
                docker logout || true
            '''

            echo "üìä R√©sum√© du build:"
            echo "Build #${env.BUILD_NUMBER}"
            echo "Image: ${DOCKER_IMAGE}:${DOCKER_TAG}"
            echo "Build n√©cessaire: ${env.BUILD_NEEDED}"

            // Sauvegarder le hash pour les builds suivants
            archiveArtifacts artifacts: 'previous_code_hash.txt', fingerprint: true
        }

        success {
            echo "‚úÖ Pipeline termin√©e avec succ√®s !"
            echo "üì¶ Image Docker: ${DOCKER_IMAGE}:${DOCKER_TAG}"
            echo "üöÄ D√©ploy√© sur Kubernetes"
            echo "üîç Analyse SonarQube compl√©t√©e"
        }

        failure {
            echo "‚ùå Pipeline √©chou√©e !"
        }

        changed {
            echo "üîÑ Statut du build chang√© depuis la derni√®re ex√©cution"
        }
    }
}
