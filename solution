D√âPLOIEMENT DE VOTRE PROJET STUDENT MANAGEMENT SUR KUBERNETES
Excellent ! Vous avez un vrai projet Spring Boot avec MySQL. Voici comment le d√©ployer sur Kubernetes.

üìÅ STRUCTURE DES FICHIERS N√âCESSAIRES
1. CORRIGER VOTRE Dockerfile
dockerfile
# ~/StudentsManagement-DevOps/Dockerfile
FROM maven:3.8.6-amazoncorretto-17 AS builder
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline -B
COPY src ./src
RUN mvn clean package -DskipTests

FROM amazoncorretto:17-alpine
WORKDIR /app
COPY --from=builder /app/target/*.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]  # CORRECTION ICI : brackets
Correction importante : Ligne 12, utilisez ["java", "-jar", "app.jar"] au lieu de "java", "-jar", "app.jar"

2. CR√âER LES FICHIERS KUBERNETES
bash
# Cr√©er le r√©pertoire pour les fichiers Kubernetes
mkdir -p ~/tp-kubernetes-student
cd ~/tp-kubernetes-student
üóÑÔ∏è PARTIE 1 : D√âPLOIEMENT MYSQL
Fichier 1 : mysql-pv-pvc.yaml
yaml
# mysql-pv-pvc.yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: mysql-pv
  namespace: devops
spec:
  capacity:
    storage: 2Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/data/mysql-student"
    type: DirectoryOrCreate
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
  namespace: devops
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 2Gi
Fichier 2 : mysql-secret.yaml
yaml
# mysql-secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-secret
  namespace: devops
type: Opaque
data:
  # echo -n "root" | base64
  root-password: cm9vdA==
  # echo -n "studentdb" | base64
  database: c3R1ZGVudGRi
Fichier 3 : mysql-deployment.yaml
yaml
# mysql-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-deployment
  namespace: devops
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: root-password
        - name: MYSQL_DATABASE
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: database
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
      volumes:
      - name: mysql-storage
        persistentVolumeClaim:
          claimName: mysql-pvc
Fichier 4 : mysql-service.yaml
yaml
# mysql-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql-service
  namespace: devops
spec:
  selector:
    app: mysql
  ports:
  - port: 3306
    targetPort: 3306
  type: ClusterIP
üå± PARTIE 2 : D√âPLOIEMENT SPRING BOOT
Fichier 5 : application-configmap.yaml
yaml
# application-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: student-app-config
  namespace: devops
data:
  application.properties: |
    spring.application.name=student-management
    spring.datasource.url=jdbc:mysql://mysql-service:3306/studentdb?createDatabaseIfNotExist=true&useSSL=false&allowPublicKeyRetrieval=true
    spring.jpa.show-sql=true
    spring.jpa.hibernate.ddl-auto=update
    spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
    
    # Server configuration
    server.port=8080
    server.servlet.context-path=/student
    
    # Swagger/OpenAPI
    springdoc.api-docs.path=/api-docs
    springdoc.swagger-ui.path=/swagger-ui.html
    
    # Logging
    logging.level.org.springframework.web=INFO
    logging.level.tn.esprit=DEBUG
Fichier 6 : application-secret.yaml
yaml
# application-secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: student-app-secret
  namespace: devops
type: Opaque
stringData:
  # Utilisez stringData pour ne pas encoder en base64
  SPRING_DATASOURCE_USERNAME: root
  SPRING_DATASOURCE_PASSWORD: root
Fichier 7 : spring-deployment.yaml
yaml
# spring-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: student-app-deployment
  namespace: devops
spec:
  replicas: 2
  selector:
    matchLabels:
      app: student-app
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    metadata:
      labels:
        app: student-app
    spec:
      containers:
      - name: student-app
        image: student-management:latest  # √Ä remplacer par votre image Docker
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_CONFIG_LOCATION
          value: file:/app/config/application.properties
        - name: SPRING_DATASOURCE_USERNAME
          valueFrom:
            secretKeyRef:
              name: student-app-secret
              key: SPRING_DATASOURCE_USERNAME
        - name: SPRING_DATASOURCE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: student-app-secret
              key: SPRING_DATASOURCE_PASSWORD
        volumeMounts:
        - name: config-volume
          mountPath: /app/config
          readOnly: true
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        readinessProbe:
          httpGet:
            path: /student/actuator/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 10
          timeoutSeconds: 5
        livenessProbe:
          httpGet:
            path: /student/actuator/health
            port: 8080
          initialDelaySeconds: 90
          periodSeconds: 20
          timeoutSeconds: 5
      volumes:
      - name: config-volume
        configMap:
          name: student-app-config
          items:
          - key: application.properties
            path: application.properties
Fichier 8 : spring-service.yaml
yaml
# spring-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: student-app-service
  namespace: devops
spec:
  selector:
    app: student-app
  ports:
  - port: 80
    targetPort: 8080
    nodePort: 30080
  type: NodePort
Fichier 9 : spring-ingress.yaml (Optionnel)
yaml
# spring-ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: student-app-ingress
  namespace: devops
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /student/$2
spec:
  rules:
  - http:
      paths:
      - path: /student(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: student-app-service
            port:
              number: 80
üöÄ PARTIE 3 : BUILD ET D√âPLOIEMENT
√âtape 1 : Build de l'image Docker
bash
# Naviguer vers votre projet
cd ~/StudentsManagement-DevOps

# 1. Corriger le Dockerfile si n√©cessaire
sed -i '12s/ENTRYPOINT "java", "-jar", "app.jar"/ENTRYPOINT ["java", "-jar", "app.jar"]/' Dockerfile

# 2. Build l'image Docker
docker build -t student-management:latest .

# 3. Tag l'image pour Minikube
docker tag student-management:latest student-management:latest

# 4. Charger l'image dans Minikube
minikube image load student-management:latest

# OU utiliser le docker daemon de Minikube
eval $(minikube docker-env)
docker build -t student-management:latest .
√âtape 2 : Cr√©er les fichiers YAML
bash
# Cr√©er tous les fichiers YAML dans le dossier tp-kubernetes-student
cd ~/tp-kubernetes-student

# Cr√©er chaque fichier avec le contenu ci-dessus
nano mysql-pv-pvc.yaml
nano mysql-secret.yaml
nano mysql-deployment.yaml
nano mysql-service.yaml
nano application-configmap.yaml
nano application-secret.yaml
nano spring-deployment.yaml
nano spring-service.yaml
√âtape 3 : Appliquer les configurations
bash
# 1. Cr√©er le namespace si pas d√©j√† fait
kubectl create namespace devops

# 2. D√©ployer MySQL
kubectl apply -f mysql-pv-pvc.yaml
kubectl apply -f mysql-secret.yaml
kubectl apply -f mysql-deployment.yaml
kubectl apply -f mysql-service.yaml

# 3. Attendre que MySQL soit pr√™t
echo "Attente de MySQL..."
sleep 30
kubectl get pods -n devops -l app=mysql

# 4. D√©ployer Spring Boot
kubectl apply -f application-configmap.yaml
kubectl apply -f application-secret.yaml
kubectl apply -f spring-deployment.yaml
kubectl apply -f spring-service.yaml

# 5. V√©rifier
kubectl get all -n devops
üîß PARTIE 4 : SCRIPT DE D√âPLOIEMENT AUTOMATIS√â
bash
#!/bin/bash
# deploy-student-app.sh

echo "=== D√âPLOIEMENT STUDENT MANAGEMENT APP ==="

# 1. Variables
PROJECT_DIR="$HOME/StudentsManagement-DevOps"
K8S_DIR="$HOME/tp-kubernetes-student"
NAMESPACE="devops"

# 2. V√©rifier Minikube
echo "V√©rification de Minikube..."
minikube status || { echo "Minikube non d√©marr√©. D√©marrage..."; minikube start; }

# 3. Cr√©er namespace
echo "Cr√©ation du namespace..."
kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

# 4. Build Docker image
echo "Build de l'image Docker..."
cd $PROJECT_DIR

# Utiliser le docker daemon de Minikube
eval $(minikube docker-env 2>/dev/null || echo "echo 'Using host docker'")

docker build -t student-management:latest .

# 5. D√©ployer MySQL
echo "D√©ploiement MySQL..."
cd $K8S_DIR

kubectl apply -f mysql-pv-pvc.yaml
sleep 5
kubectl apply -f mysql-secret.yaml
kubectl apply -f mysql-deployment.yaml
kubectl apply -f mysql-service.yaml

echo "Attente du d√©marrage de MySQL..."
sleep 40

# 6. V√©rifier MySQL
MYSQL_POD=$(kubectl get pods -n $NAMESPACE -l app=mysql -o jsonpath='{.items[0].metadata.name}')
if [ -n "$MYSQL_POD" ]; then
    echo "V√©rification MySQL..."
    kubectl exec -n $NAMESPACE $MYSQL_POD -- mysql -uroot -proot -e "CREATE DATABASE IF NOT EXISTS studentdb; SHOW DATABASES;" 2>/dev/null
fi

# 7. D√©ployer Spring Boot
echo "D√©ploiement Spring Boot..."
kubectl apply -f application-configmap.yaml
kubectl apply -f application-secret.yaml

# Mettre √† jour l'image dans le deployment
sed -i 's|image: student-management:latest|image: student-management:latest|g' spring-deployment.yaml
kubectl apply -f spring-deployment.yaml
kubectl apply -f spring-service.yaml

# 8. Attendre l'application
echo "Attente du d√©marrage de l'application..."
sleep 60

# 9. V√©rification
echo "=== V√âRIFICATION ==="
kubectl get all -n $NAMESPACE

echo -e "\n=== URLS ==="
echo "MySQL interne: mysql-service:3306"
echo "Application: $(minikube service student-app-service -n $NAMESPACE --url)"

echo -e "\n=== COMMANDES UTILES ==="
echo "1. Logs Spring: kubectl logs -n $NAMESPACE deployment/student-app-deployment -f"
echo "2. Shell MySQL: kubectl exec -n $NAMESPACE -it $MYSQL_POD -- mysql -uroot -proot"
echo "3. Acc√®s web: minikube service student-app-service -n $NAMESPACE"

echo -e "\n=== D√âPLOIEMENT TERMIN√â ==="
üìù PARTIE 5 : PIPELINE JENKINS POUR VOTRE PROJET
Jenkinsfile pour votre projet
groovy
// Jenkinsfile
pipeline {
    agent any
    
    environment {
        DOCKER_IMAGE = 'student-management'
        K8S_NAMESPACE = 'devops'
        REGISTRY = ''  // Docker Hub ou registry priv√©
    }
    
    stages {
        stage('Checkout') {
            steps {
                git branch: 'main', 
                url: 'https://github.com/votre-repo/StudentsManagement-DevOps.git'
                // Ou utiliser un d√©p√¥t local
                // checkout scm
            }
        }
        
        stage('Build with Maven') {
            steps {
                sh '''
                echo "Building Spring Boot application..."
                mvn clean package -DskipTests
                ls -la target/*.jar
                '''
            }
        }
        
        stage('Run Tests') {
            steps {
                sh 'mvn test'
            }
        }
        
        stage('Build Docker Image') {
            steps {
                script {
                    // Build avec Minikube Docker
                    sh '''
                    eval $(minikube docker-env)
                    docker build -t ${DOCKER_IMAGE}:${BUILD_NUMBER} .
                    docker tag ${DOCKER_IMAGE}:${BUILD_NUMBER} ${DOCKER_IMAGE}:latest
                    '''
                }
            }
        }
        
        stage('Deploy to Kubernetes') {
            steps {
                script {
                    dir('k8s') {
                        // Mettre √† jour l'image dans le deployment
                        sh """
                        sed -i 's|image: ${DOCKER_IMAGE}:.*|image: ${DOCKER_IMAGE}:${BUILD_NUMBER}|g' spring-deployment.yaml
                        
                        # Appliquer les configurations
                        kubectl apply -f mysql-pv-pvc.yaml -n ${K8S_NAMESPACE}
                        kubectl apply -f mysql-secret.yaml -n ${K8S_NAMESPACE}
                        kubectl apply -f mysql-deployment.yaml -n ${K8S_NAMESPACE}
                        kubectl apply -f mysql-service.yaml -n ${K8S_NAMESPACE}
                        
                        # Attendre MySQL
                        sleep 30
                        
                        kubectl apply -f application-configmap.yaml -n ${K8S_NAMESPACE}
                        kubectl apply -f application-secret.yaml -n ${K8S_NAMESPACE}
                        kubectl apply -f spring-deployment.yaml -n ${K8S_NAMESPACE}
                        kubectl apply -f spring-service.yaml -n ${K8S_NAMESPACE}
                        
                        # V√©rifier le d√©ploiement
                        kubectl rollout status deployment/student-app-deployment -n ${K8S_NAMESPACE}
                        """
                    }
                }
            }
        }
        
        stage('Smoke Test') {
            steps {
                script {
                    sh '''
                    sleep 30
                    URL=$(minikube service student-app-service -n ${K8S_NAMESPACE} --url)
                    echo "Testing application at: ${URL}"
                    curl -f ${URL}/student/actuator/health || curl -f ${URL}/student
                    '''
                }
            }
        }
    }
    
    post {
        success {
            echo '‚úÖ Pipeline r√©ussi! Application d√©ploy√©e.'
        }
        failure {
            echo '‚ùå Pipeline √©chou√©! V√©rifier les logs.'
            sh '''
            kubectl get pods -n ${K8S_NAMESPACE}
            kubectl logs -n ${K8S_NAMESPACE} deployment/student-app-deployment --tail=50
            '''
        }
    }
}
üîç PARTIE 6 : V√âRIFICATION ET TESTS
Script de v√©rification
bash
#!/bin/bash
# verify-deployment.sh

echo "=== V√âRIFICATION DU D√âPLOIEMENT ==="

NAMESPACE="devops"

echo "1. √âtat des pods:"
kubectl get pods -n $NAMESPACE -o wide

echo -e "\n2. √âtat des services:"
kubectl get svc -n $NAMESPACE

echo -e "\n3. Logs MySQL:"
MYSQL_POD=$(kubectl get pods -n $NAMESPACE -l app=mysql -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
if [ -n "$MYSQL_POD" ]; then
    kubectl logs -n $NAMESPACE $MYSQL_POD --tail=10
else
    echo "MySQL pod non trouv√©"
fi

echo -e "\n4. Logs Spring Boot:"
SPRING_POD=$(kubectl get pods -n $NAMESPACE -l app=student-app -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
if [ -n "$SPRING_POD" ]; then
    kubectl logs -n $NAMESPACE $SPRING_POD --tail=20
else
    echo "Spring Boot pod non trouv√©"
fi

echo -e "\n5. Test de connexion MySQL:"
if [ -n "$MYSQL_POD" ]; then
    kubectl exec -n $NAMESPACE $MYSQL_POD -- mysql -uroot -proot -e "USE studentdb; SHOW TABLES;" 2>/dev/null || echo "Connexion √©chou√©e"
fi

echo -e "\n6. Test de l'application:"
URL=$(minikube service student-app-service -n $NAMESPACE --url 2>/dev/null)
if [ -n "$URL" ]; then
    echo "URL: $URL"
    echo "Test health endpoint:"
    curl -s "${URL}/student/actuator/health" | head -5
    echo -e "\nTest API endpoint:"
    curl -s "${URL}/student/api/students" | head -5
else
    echo "Service non accessible"
fi

echo -e "\n7. √âv√©nements r√©cents:"
kubectl get events -n $NAMESPACE --sort-by='.lastTimestamp' | tail -10

echo -e "\n=== V√âRIFICATION TERMIN√âE ==="
üìä TABLEAU DE V√âRIFICATION POUR VOTRE TP
√âtape	Fichier	Commande de v√©rification	R√©sultat attendu
1. MySQL PV/PVC	mysql-pv-pvc.yaml	kubectl get pv,pvc -n devops	1 PV + 1 PVC Bound
2. MySQL Secret	mysql-secret.yaml	kubectl get secret mysql-secret -n devops	Secret cr√©√©
3. MySQL Deployment	mysql-deployment.yaml	kubectl get pods -n devops -l app=mysql	1/1 Running
4. MySQL Service	mysql-service.yaml	kubectl get svc mysql-service -n devops	ClusterIP 3306
5. App ConfigMap	application-configmap.yaml	kubectl get configmap student-app-config -n devops -o yaml	Config cr√©√©e
6. App Secret	application-secret.yaml	kubectl get secret student-app-secret -n devops	Secret cr√©√©
7. Spring Deployment	spring-deployment.yaml	kubectl get pods -n devops -l app=student-app	2/2 Running
8. Spring Service	spring-service.yaml	kubectl get svc student-app-service -n devops	NodePort 30080
9. Test DB	-	kubectl exec -it mysql-pod -- mysql -uroot -proot -e "SHOW DATABASES;"	Voir studentdb
10. Test App	-	curl $(minikube service student-app-service --url)/student/actuator/health	{"status":"UP"}
üö® D√âPANNAGE SP√âCIFIQUE √Ä VOTRE PROJET
Probl√®me 1 : Connexion √† MySQL √©choue
bash
# V√©rifier les logs MySQL
kubectl logs -n devops deployment/mysql-deployment

# V√©rifier la connexion depuis un pod test
kubectl run mysql-test --image=mysql:8.0 -n devops --rm -it -- \
  mysql -hmysql-service -uroot -proot -e "SHOW DATABASES;"

# Si √©chec, recr√©er le secret
kubectl delete secret mysql-secret -n devops
kubectl apply -f mysql-secret.yaml
Probl√®me 2 : Spring Boot ne d√©marre pas
bash
# V√©rifier les logs
kubectl logs -n devops deployment/student-app-deployment

# V√©rifier les variables d'environnement
kubectl exec -n devops $(kubectl get pods -n devops -l app=student-app -o jsonpath='{.items[0].metadata.name}') -- env | grep SPRING

# V√©rifier le fichier de configuration mont√©
kubectl exec -n devops $(kubectl get pods -n devops -l app=student-app -o jsonpath='{.items[0].metadata.name}') -- cat /app/config/application.properties
Probl√®me 3 : Port 8089 vs 8080
Votre application.properties utilise server.port=8089, mais Kubernetes expose 8080. Solutions :

Option A : Modifier le Dockerfile (recommand√©)

dockerfile
# Modifier l'EXPOSE
EXPOSE 8089
Option B : Modifier les fichiers Kubernetes

yaml
# Dans spring-deployment.yaml
containerPort: 8089

# Dans spring-service.yaml
targetPort: 8089
üéâ √âTAPES FINALES POUR VOTRE TP
Corriger le Dockerfile (ligne 12)

Cr√©er les 8 fichiers YAML dans ~/tp-kubernetes-student/

Build l'image Docker avec Minikube

Appliquer les configurations avec kubectl apply

V√©rifier avec le script verify-deployment.sh

Tester l'application : minikube service student-app-service --url

Votre application Spring Boot "Student Management" est maintenant d√©ploy√©e sur Kubernetes avec :

apiVersion: v1
kind: PersistentVolume
metadata:
  name: mysql-pv
  namespace: devops
spec:
  capacity:
    storage: 2Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/data/mysql-student"
    type: DirectoryOrCreate
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
  namespace: devops
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 2Gi
