DÃ‰PLOIEMENT DE VOTRE PROJET STUDENT MANAGEMENT SUR KUBERNETES
Excellent ! Vous avez un vrai projet Spring Boot avec MySQL. Voici comment le dÃ©ployer sur Kubernetes.

ðŸ“ STRUCTURE DES FICHIERS NÃ‰CESSAIRES
1. CORRIGER VOTRE Dockerfile
dockerfile
# ~/StudentsManagement-DevOps/Dockerfile
FROM maven:3.8.6-amazoncorretto-17 AS builder
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline -B
COPY src ./src
RUN mvn clean package -DskipTests

FROM amazoncorretto:17-alpine
WORKDIR /app
COPY --from=builder /app/target/*.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]  # CORRECTION ICI : brackets
Correction importante : Ligne 12, utilisez ["java", "-jar", "app.jar"] au lieu de "java", "-jar", "app.jar"

2. CRÃ‰ER LES FICHIERS KUBERNETES
bash
# CrÃ©er le rÃ©pertoire pour les fichiers Kubernetes
mkdir -p ~/tp-kubernetes-student
cd ~/tp-kubernetes-student
ðŸ—„ï¸ PARTIE 1 : DÃ‰PLOIEMENT MYSQL
Fichier 1 : mysql-pv-pvc.yaml
yaml
# mysql-pv-pvc.yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: mysql-pv
  namespace: devops
spec:
  capacity:
    storage: 2Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/data/mysql-student"
    type: DirectoryOrCreate
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
  namespace: devops
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 2Gi
Fichier 2 : mysql-secret.yaml
yaml
# mysql-secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-secret
  namespace: devops
type: Opaque
data:
  # echo -n "root" | base64
  root-password: cm9vdA==
  # echo -n "studentdb" | base64
  database: c3R1ZGVudGRi
Fichier 3 : mysql-deployment.yaml
yaml
# mysql-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-deployment
  namespace: devops
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: root-password
        - name: MYSQL_DATABASE
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: database
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
      volumes:
      - name: mysql-storage
        persistentVolumeClaim:
          claimName: mysql-pvc
Fichier 4 : mysql-service.yaml
yaml
# mysql-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql-service
  namespace: devops
spec:
  selector:
    app: mysql
  ports:
  - port: 3306
    targetPort: 3306
  type: ClusterIP
ðŸŒ± PARTIE 2 : DÃ‰PLOIEMENT SPRING BOOT
Fichier 5 : application-configmap.yaml
yaml
# application-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: student-app-config
  namespace: devops
data:
  application.properties: |
    spring.application.name=student-management
    spring.datasource.url=jdbc:mysql://mysql-service:3306/studentdb?createDatabaseIfNotExist=true&useSSL=false&allowPublicKeyRetrieval=true
    spring.jpa.show-sql=true
    spring.jpa.hibernate.ddl-auto=update
    spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
    
    # Server configuration
    server.port=8080
    server.servlet.context-path=/student
    
    # Swagger/OpenAPI
    springdoc.api-docs.path=/api-docs
    springdoc.swagger-ui.path=/swagger-ui.html
    
    # Logging
    logging.level.org.springframework.web=INFO
    logging.level.tn.esprit=DEBUG
Fichier 6 : application-secret.yaml
yaml
# application-secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: student-app-secret
  namespace: devops
type: Opaque
stringData:
  # Utilisez stringData pour ne pas encoder en base64
  SPRING_DATASOURCE_USERNAME: root
  SPRING_DATASOURCE_PASSWORD: root
Fichier 7 : spring-deployment.yaml
yaml
# spring-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: student-app-deployment
  namespace: devops
spec:
  replicas: 2
  selector:
    matchLabels:
      app: student-app
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    metadata:
      labels:
        app: student-app
    spec:
      containers:
      - name: student-app
        image: student-management:latest  # Ã€ remplacer par votre image Docker
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_CONFIG_LOCATION
          value: file:/app/config/application.properties
        - name: SPRING_DATASOURCE_USERNAME
          valueFrom:
            secretKeyRef:
              name: student-app-secret
              key: SPRING_DATASOURCE_USERNAME
        - name: SPRING_DATASOURCE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: student-app-secret
              key: SPRING_DATASOURCE_PASSWORD
        volumeMounts:
        - name: config-volume
          mountPath: /app/config
          readOnly: true
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        readinessProbe:
          httpGet:
            path: /student/actuator/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 10
          timeoutSeconds: 5
        livenessProbe:
          httpGet:
            path: /student/actuator/health
            port: 8080
          initialDelaySeconds: 90
          periodSeconds: 20
          timeoutSeconds: 5
      volumes:
      - name: config-volume
        configMap:
          name: student-app-config
          items:
          - key: application.properties
            path: application.properties
Fichier 8 : spring-service.yaml
yaml
# spring-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: student-app-service
  namespace: devops
spec:
  selector:
    app: student-app
  ports:
  - port: 80
    targetPort: 8080
    nodePort: 30080
  type: NodePort
Fichier 9 : spring-ingress.yaml (Optionnel)
yaml
# spring-ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: student-app-ingress
  namespace: devops
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /student/$2
spec:
  rules:
  - http:
      paths:
      - path: /student(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: student-app-service
            port:
              number: 80
ðŸš€ PARTIE 3 : BUILD ET DÃ‰PLOIEMENT
Ã‰tape 1 : Build de l'image Docker
bash
# Naviguer vers votre projet
cd ~/StudentsManagement-DevOps

# 1. Corriger le Dockerfile si nÃ©cessaire
sed -i '12s/ENTRYPOINT "java", "-jar", "app.jar"/ENTRYPOINT ["java", "-jar", "app.jar"]/' Dockerfile

# 2. Build l'image Docker
docker build -t student-management:latest .

# 3. Tag l'image pour Minikube
docker tag student-management:latest student-management:latest

# 4. Charger l'image dans Minikube
minikube image load student-management:latest

# OU utiliser le docker daemon de Minikube
eval $(minikube docker-env)
docker build -t student-management:latest .
Ã‰tape 2 : CrÃ©er les fichiers YAML
bash
# CrÃ©er tous les fichiers YAML dans le dossier tp-kubernetes-student
cd ~/tp-kubernetes-student

# CrÃ©er chaque fichier avec le contenu ci-dessus
nano mysql-pv-pvc.yaml
nano mysql-secret.yaml
nano mysql-deployment.yaml
nano mysql-service.yaml
nano application-configmap.yaml
nano application-secret.yaml
nano spring-deployment.yaml
nano spring-service.yaml
Ã‰tape 3 : Appliquer les configurations
bash
# 1. CrÃ©er le namespace si pas dÃ©jÃ  fait
kubectl create namespace devops

# 2. DÃ©ployer MySQL
kubectl apply -f mysql-pv-pvc.yaml
kubectl apply -f mysql-secret.yaml
kubectl apply -f mysql-deployment.yaml
kubectl apply -f mysql-service.yaml

# 3. Attendre que MySQL soit prÃªt
echo "Attente de MySQL..."
sleep 30
kubectl get pods -n devops -l app=mysql

# 4. DÃ©ployer Spring Boot
kubectl apply -f application-configmap.yaml
kubectl apply -f application-secret.yaml
kubectl apply -f spring-deployment.yaml
kubectl apply -f spring-service.yaml

# 5. VÃ©rifier
kubectl get all -n devops
ðŸ”§ PARTIE 4 : SCRIPT DE DÃ‰PLOIEMENT AUTOMATISÃ‰
bash
#!/bin/bash
# deploy-student-app.sh

echo "=== DÃ‰PLOIEMENT STUDENT MANAGEMENT APP ==="

# 1. Variables
PROJECT_DIR="$HOME/StudentsManagement-DevOps"
K8S_DIR="$HOME/tp-kubernetes-student"
NAMESPACE="devops"

# 2. VÃ©rifier Minikube
echo "VÃ©rification de Minikube..."
minikube status || { echo "Minikube non dÃ©marrÃ©. DÃ©marrage..."; minikube start; }

# 3. CrÃ©er namespace
echo "CrÃ©ation du namespace..."
kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

# 4. Build Docker image
echo "Build de l'image Docker..."
cd $PROJECT_DIR

# Utiliser le docker daemon de Minikube
eval $(minikube docker-env 2>/dev/null || echo "echo 'Using host docker'")

docker build -t student-management:latest .

# 5. DÃ©ployer MySQL
echo "DÃ©ploiement MySQL..."
cd $K8S_DIR

kubectl apply -f mysql-pv-pvc.yaml
sleep 5
kubectl apply -f mysql-secret.yaml
kubectl apply -f mysql-deployment.yaml
kubectl apply -f mysql-service.yaml

echo "Attente du dÃ©marrage de MySQL..."
sleep 40

# 6. VÃ©rifier MySQL
MYSQL_POD=$(kubectl get pods -n $NAMESPACE -l app=mysql -o jsonpath='{.items[0].metadata.name}')
if [ -n "$MYSQL_POD" ]; then
    echo "VÃ©rification MySQL..."
    kubectl exec -n $NAMESPACE $MYSQL_POD -- mysql -uroot -proot -e "CREATE DATABASE IF NOT EXISTS studentdb; SHOW DATABASES;" 2>/dev/null
fi

# 7. DÃ©ployer Spring Boot
echo "DÃ©ploiement Spring Boot..."
kubectl apply -f application-configmap.yaml
kubectl apply -f application-secret.yaml

# Mettre Ã  jour l'image dans le deployment
sed -i 's|image: student-management:latest|image: student-management:latest|g' spring-deployment.yaml
kubectl apply -f spring-deployment.yaml
kubectl apply -f spring-service.yaml

# 8. Attendre l'application
echo "Attente du dÃ©marrage de l'application..."
sleep 60

# 9. VÃ©rification
echo "=== VÃ‰RIFICATION ==="
kubectl get all -n $NAMESPACE

echo -e "\n=== URLS ==="
echo "MySQL interne: mysql-service:3306"
echo "Application: $(minikube service student-app-service -n $NAMESPACE --url)"

echo -e "\n=== COMMANDES UTILES ==="
echo "1. Logs Spring: kubectl logs -n $NAMESPACE deployment/student-app-deployment -f"
echo "2. Shell MySQL: kubectl exec -n $NAMESPACE -it $MYSQL_POD -- mysql -uroot -proot"
echo "3. AccÃ¨s web: minikube service student-app-service -n $NAMESPACE"

echo -e "\n=== DÃ‰PLOIEMENT TERMINÃ‰ ==="
ðŸ“ PARTIE 5 : PIPELINE JENKINS POUR VOTRE PROJET
Jenkinsfile pour votre projet
groovy
// Jenkinsfile
pipeline {
    agent any
    
    environment {
        DOCKER_IMAGE = 'student-management'
        K8S_NAMESPACE = 'devops'
        REGISTRY = ''  // Docker Hub ou registry privÃ©
    }
    
    stages {
        stage('Checkout') {
            steps {
                git branch: 'main', 
                url: 'https://github.com/votre-repo/StudentsManagement-DevOps.git'
                // Ou utiliser un dÃ©pÃ´t local
                // checkout scm
            }
        }
        
        stage('Build with Maven') {
            steps {
                sh '''
                echo "Building Spring Boot application..."
                mvn clean package -DskipTests
                ls -la target/*.jar
                '''
            }
        }
        
        stage('Run Tests') {
            steps {
                sh 'mvn test'
            }
        }
        
        stage('Build Docker Image') {
            steps {
                script {
                    // Build avec Minikube Docker
                    sh '''
                    eval $(minikube docker-env)
                    docker build -t ${DOCKER_IMAGE}:${BUILD_NUMBER} .
                    docker tag ${DOCKER_IMAGE}:${BUILD_NUMBER} ${DOCKER_IMAGE}:latest
                    '''
                }
            }
        }
        
        stage('Deploy to Kubernetes') {
            steps {
                script {
                    dir('k8s') {
                        // Mettre Ã  jour l'image dans le deployment
                        sh """
                        sed -i 's|image: ${DOCKER_IMAGE}:.*|image: ${DOCKER_IMAGE}:${BUILD_NUMBER}|g' spring-deployment.yaml
                        
                        # Appliquer les configurations
                        kubectl apply -f mysql-pv-pvc.yaml -n ${K8S_NAMESPACE}
                        kubectl apply -f mysql-secret.yaml -n ${K8S_NAMESPACE}
                        kubectl apply -f mysql-deployment.yaml -n ${K8S_NAMESPACE}
                        kubectl apply -f mysql-service.yaml -n ${K8S_NAMESPACE}
                        
                        # Attendre MySQL
                        sleep 30
                        
                        kubectl apply -f application-configmap.yaml -n ${K8S_NAMESPACE}
                        kubectl apply -f application-secret.yaml -n ${K8S_NAMESPACE}
                        kubectl apply -f spring-deployment.yaml -n ${K8S_NAMESPACE}
                        kubectl apply -f spring-service.yaml -n ${K8S_NAMESPACE}
                        
                        # VÃ©rifier le dÃ©ploiement
                        kubectl rollout status deployment/student-app-deployment -n ${K8S_NAMESPACE}
                        """
                    }
                }
            }
        }
        
        stage('Smoke Test') {
            steps {
                script {
                    sh '''
                    sleep 30
                    URL=$(minikube service student-app-service -n ${K8S_NAMESPACE} --url)
                    echo "Testing application at: ${URL}"
                    curl -f ${URL}/student/actuator/health || curl -f ${URL}/student
                    '''
                }
            }
        }
    }
    
    post {
        success {
            echo 'âœ… Pipeline rÃ©ussi! Application dÃ©ployÃ©e.'
        }
        failure {
            echo 'âŒ Pipeline Ã©chouÃ©! VÃ©rifier les logs.'
            sh '''
            kubectl get pods -n ${K8S_NAMESPACE}
            kubectl logs -n ${K8S_NAMESPACE} deployment/student-app-deployment --tail=50
            '''
        }
    }
}
ðŸ” PARTIE 6 : VÃ‰RIFICATION ET TESTS
Script de vÃ©rification
bash
#!/bin/bash
# verify-deployment.sh

echo "=== VÃ‰RIFICATION DU DÃ‰PLOIEMENT ==="

NAMESPACE="devops"

echo "1. Ã‰tat des pods:"
kubectl get pods -n $NAMESPACE -o wide

echo -e "\n2. Ã‰tat des services:"
kubectl get svc -n $NAMESPACE

echo -e "\n3. Logs MySQL:"
MYSQL_POD=$(kubectl get pods -n $NAMESPACE -l app=mysql -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
if [ -n "$MYSQL_POD" ]; then
    kubectl logs -n $NAMESPACE $MYSQL_POD --tail=10
else
    echo "MySQL pod non trouvÃ©"
fi

echo -e "\n4. Logs Spring Boot:"
SPRING_POD=$(kubectl get pods -n $NAMESPACE -l app=student-app -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
if [ -n "$SPRING_POD" ]; then
    kubectl logs -n $NAMESPACE $SPRING_POD --tail=20
else
    echo "Spring Boot pod non trouvÃ©"
fi

echo -e "\n5. Test de connexion MySQL:"
if [ -n "$MYSQL_POD" ]; then
    kubectl exec -n $NAMESPACE $MYSQL_POD -- mysql -uroot -proot -e "USE studentdb; SHOW TABLES;" 2>/dev/null || echo "Connexion Ã©chouÃ©e"
fi

echo -e "\n6. Test de l'application:"
URL=$(minikube service student-app-service -n $NAMESPACE --url 2>/dev/null)
if [ -n "$URL" ]; then
    echo "URL: $URL"
    echo "Test health endpoint:"
    curl -s "${URL}/student/actuator/health" | head -5
    echo -e "\nTest API endpoint:"
    curl -s "${URL}/student/api/students" | head -5
else
    echo "Service non accessible"
fi

echo -e "\n7. Ã‰vÃ©nements rÃ©cents:"
kubectl get events -n $NAMESPACE --sort-by='.lastTimestamp' | tail -10

echo -e "\n=== VÃ‰RIFICATION TERMINÃ‰E ==="
ðŸ“Š TABLEAU DE VÃ‰RIFICATION POUR VOTRE TP
Ã‰tape	Fichier	Commande de vÃ©rification	RÃ©sultat attendu
1. MySQL PV/PVC	mysql-pv-pvc.yaml	kubectl get pv,pvc -n devops	1 PV + 1 PVC Bound
2. MySQL Secret	mysql-secret.yaml	kubectl get secret mysql-secret -n devops	Secret crÃ©Ã©
3. MySQL Deployment	mysql-deployment.yaml	kubectl get pods -n devops -l app=mysql	1/1 Running
4. MySQL Service	mysql-service.yaml	kubectl get svc mysql-service -n devops	ClusterIP 3306
5. App ConfigMap	application-configmap.yaml	kubectl get configmap student-app-config -n devops -o yaml	Config crÃ©Ã©e
6. App Secret	application-secret.yaml	kubectl get secret student-app-secret -n devops	Secret crÃ©Ã©
7. Spring Deployment	spring-deployment.yaml	kubectl get pods -n devops -l app=student-app	2/2 Running
8. Spring Service	spring-service.yaml	kubectl get svc student-app-service -n devops	NodePort 30080
9. Test DB	-	kubectl exec -it mysql-pod -- mysql -uroot -proot -e "SHOW DATABASES;"	Voir studentdb
10. Test App	-	curl $(minikube service student-app-service --url)/student/actuator/health	{"status":"UP"}
ðŸš¨ DÃ‰PANNAGE SPÃ‰CIFIQUE Ã€ VOTRE PROJET
ProblÃ¨me 1 : Connexion Ã  MySQL Ã©choue
bash
# VÃ©rifier les logs MySQL
kubectl logs -n devops deployment/mysql-deployment

# VÃ©rifier la connexion depuis un pod test
kubectl run mysql-test --image=mysql:8.0 -n devops --rm -it -- \
  mysql -hmysql-service -uroot -proot -e "SHOW DATABASES;"

# Si Ã©chec, recrÃ©er le secret
kubectl delete secret mysql-secret -n devops
kubectl apply -f mysql-secret.yaml
ProblÃ¨me 2 : Spring Boot ne dÃ©marre pas
bash
# VÃ©rifier les logs
kubectl logs -n devops deployment/student-app-deployment

# VÃ©rifier les variables d'environnement
kubectl exec -n devops $(kubectl get pods -n devops -l app=student-app -o jsonpath='{.items[0].metadata.name}') -- env | grep SPRING

# VÃ©rifier le fichier de configuration montÃ©
kubectl exec -n devops $(kubectl get pods -n devops -l app=student-app -o jsonpath='{.items[0].metadata.name}') -- cat /app/config/application.properties
ProblÃ¨me 3 : Port 8089 vs 8080
Votre application.properties utilise server.port=8089, mais Kubernetes expose 8080. Solutions :

Option A : Modifier le Dockerfile (recommandÃ©)

dockerfile
# Modifier l'EXPOSE
EXPOSE 8089
Option B : Modifier les fichiers Kubernetes

yaml
# Dans spring-deployment.yaml
containerPort: 8089

# Dans spring-service.yaml
targetPort: 8089
ðŸŽ‰ Ã‰TAPES FINALES POUR VOTRE TP
Corriger le Dockerfile (ligne 12)

CrÃ©er les 8 fichiers YAML dans ~/tp-kubernetes-student/

Build l'image Docker avec Minikube

Appliquer les configurations avec kubectl apply

VÃ©rifier avec le script verify-deployment.sh

Tester l'application : minikube service student-app-service --url

Votre application Spring Boot "Student Management" est maintenant dÃ©ployÃ©e sur Kubernetes avec :

apiVersion: v1
kind: PersistentVolume
metadata:
  name: mysql-pv
  namespace: devops
spec:
  capacity:
    storage: 2Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/data/mysql-student"
    type: DirectoryOrCreate
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
  namespace: devops
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 2Gi






Option 1 : Supprimer et recrÃ©er les ressources (recommandÃ©)
bash
# D'abord, supprimer le dÃ©ploiement MySQL qui utilise le PVC
kubectl delete -f mysql-deployment.yaml

# Ensuite, supprimer le PVC et PV
kubectl delete pvc mysql-pvc -n devops
kubectl delete pv mysql-pv

# Corriger d'abord le fichier YAML (corrige les erreurs)
# Puis appliquer Ã  nouveau
kubectl apply -f mysql-pv-pvc.yaml
kubectl apply -f mysql-deployment.yaml


**************************************************************


[INFO] Results:
[INFO] 
[ERROR] Errors: 
[ERROR]   StudentManagementApplicationTests.contextLoads Â» IllegalState Failed to load ApplicationContext for [WebMergedContextConfiguration@74ce7fdf testClass = tn.esprit.studentmanagement.StudentManagementApplicationTests, locations = [], classes = [tn.esprit.studentmanagement.StudentManagementApplication], contextInitializerClasses = [], activeProfiles = [], propertySourceDescriptors = [], propertySourceProperties = ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"], contextCustomizers = [org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@6fa51cd4, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@cecf639, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.web.client.TestRestTemplateContextCustomizer@6be968ce, org.springframework.boot.test.web.reactor.netty.DisableReactorResourceFactoryGlobalResourcesContextCustomizerFactory$DisableReactorResourceFactoryGlobalResourcesContextCustomizerCustomizer@61c4eee0, org.springframework.boot.test.autoconfigure.OnFailureConditionReportContextCustomizerFactory$OnFailureConditionReportContextCustomizer@548a24a, org.springframework.boot.test.autoconfigure.actuate.observability.ObservabilityContextCustomizerFactory$DisableObservabilityContextCustomizer@1f, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@0, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizer@2a8448fa, org.springframework.test.context.support.DynamicPropertiesContextCustomizer@0, org.springframework.boot.test.context.SpringBootTestAnnotation@b0e76353], resourceBasePath = "src/main/webapp", contextLoader = org.springframework.boot.test.context.SpringBootContextLoader, parent = null]
[INFO] 
[ERROR] Tests run: 1, Failures: 0, Errors: 1, Skipped: 0
[INFO] 
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  13.251 s
[INFO] Finished at: 2025-12-12T15:09:50+01:00
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:3.5.3:test (default-test) on project student-management: 
[ERROR] 
[ERROR] See /home/ahmed/StudentsManagement-DevOps/target/surefire-reports for the individual test results.
[ERROR] See dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date].dumpstream.
[ERROR] -> [Help 1]
[ERROR] 
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR] 
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException

